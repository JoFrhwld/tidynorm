% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/norm.R
\name{norm_generic}
\alias{norm_generic}
\title{Generic normalization procedure}
\usage{
norm_generic(
  .data,
  ...,
  .by = NULL,
  .norm_fun = identity_norm_fun,
  .by_formant = FALSE,
  .drop_orig = FALSE,
  .keep_params = FALSE,
  .names = "{.col}_n",
  .silent = FALSE,
  .call = caller_env()
)
}
\arguments{
\item{.data}{A data frame containing vowel formant data}

\item{...}{\code{\link[dplyr:dplyr_tidy_select]{<tidy-select>}} One or more unquoted
expressions separated by commas. These should target the vowel formant
data columns.}

\item{.by}{\code{\link[dplyr:dplyr_tidy_select]{<tidy-select>}} A selection of
columns to group by. Typically a column of speaker IDs.}

\item{.norm_fun}{A function to apply to a pivoted long data frame. See
Details for how to write such a function.}

\item{.by_formant}{Whether or not the normalization method is formant
intrinsic.}

\item{.drop_orig}{Whether or not to drop the original formant data columns.}

\item{.keep_params}{Whether or not to keep the Location (\verb{*_L}) and scale
(\verb{*_S}) normalization parameters}

\item{.names}{A \code{\link[glue:glue]{glue::glue()}} expression for naming the normalized
data columns. The \code{"{.col}"} portion corresponds to the name of the original
formant columns.}

\item{.call}{Used for internal purposes.}
}
\description{
This is a generic normalization procedure with which
you can create your own normalization method.
}
\details{
The following \verb{norm_*} procedures are built on top of \code{norm_generic()}.
\itemize{
\item \link{norm_lobanov}
\item \link{norm_nearey}
\item \link{norm_deltaF}
}

You can define a custom normalization function to pass
to \code{.norm_fun} that takes the following arguments
\itemize{
\item \code{.data}
\item \code{.grouping}
\item \code{.names}
}

The \code{.data} data frame will be your original data frame with the
formant columns pivoted longer. The formant names will be available
in a column called \code{.formant}, and the formant values in a column
called \code{.col}. Any Location parameters should be assigned to a
column called \code{L}, and any Scale parameters should be assigned
to a column called \code{S}. A median-based normalization function might
look like the following.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{median_norm_fun <- function(.data, .grouping, .names)\{
  .data |>
    mutate(
      .by = !!.grouping,
      L = median(.col),
      S = mad(.col),
      across(
        .col,
        .fns = \\(x) (x - L)/S,
        .names = .names
      )
    )
 return(.data)
\}
}\if{html}{\out{</div>}}

If the method is meant to be formant ex/intrinsic, as
defined by \code{.by_formant}, this will be accounted for by
the grouping variables in the \code{.grouping} argument passed
to the normalization function.
}
\examples{
library(tidynorm)
library(dplyr)

median_norm_fun <- function(.data, .grouping, .names){
  .data <- .data |>
    mutate(
      .by = !!.grouping,
      L = median(.col, na.rm = TRUE),
      S = mad(.col, na.rm = TRUE),
      across(
        .col,
        .fns = \(x) (x - L)/S,
        .names = .names
      )
    )
  return(.data)
}

speaker_data |>
  norm_generic(
    F1:F3,
    .by = speaker,
    .norm_fun = median_norm_fun,
    .by_formant = TRUE,
    .drop_orig = TRUE,
    .names = "{.col}_mad"
  )

}
