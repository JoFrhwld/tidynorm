---
title: dct-experiment
---

```{r}
library(tidynorm)
library(dplyr)
library(tidyr)
library(ggplot2)
library(reticulate)
# library(quickr)
# scipy <- import("scipy")
# p_dct <- scipy$fft$dct
```

```{r}
x <- seq(0,1, length = 10)
y <- 5 + x + (2 * (x^2)) + (-2 * (x^4))
```

```{r}
dct_q(y)
```

```{r}
cos_bank <- function(kk, jj = kk){
  declare(
    type(kk = integer(1)),
    type(jj = integer(1)),
    type(pi = double(1)),
    type(norm_forward = logical(1))
  )
  
  pi = 4*(4*atan(1/5) - atan(1/239))
  
  k_vec = double(length = kk)
  j_vec = double(length = jj)
  
  k_vec = 0:(kk - 1)
  j_vec = 0:(jj - 1)
  
  bank = matrix(0, nrow = jj, ncol = kk)
  
  for (j in seq_along(j_vec)) {
    for (k in seq_along(k_vec)) {
      bank[k,j] = cos((pi * (k - 1) * ((2*(j - 1)) + 1))/(2*jj))
    }
  }
  
  bank
}
```

```{r}
cos_bank_q = quick(cos_bank)
```

```{r}
dct_base = function(
    y, 
    kk = length(y), 
    jj = length(y), 
    forward = TRUE
  ) {
  declare(
    type(y = double(NA)),
    type(kk = integer(1)),
    type(jj = integer(1)),
    type(pi = double(1)),
    type(forward = logical(1))
  )
  
  pi = 4*(4*atan(1/5) - atan(1/239))

  k_vec = 0:(kk - 1)
  j_vec = 0:(jj - 1)
  N = 0.0
  
  bank = matrix(0, nrow = kk, ncol = jj)
  
  for (j in seq_along(j_vec)) {
    N = N + 1.0
    for (k in seq_along(k_vec)) {
      bank[k,j] = cos((pi * (k - 1) * ((2*(j - 1)) + 1))/(2*jj))
    }
  }
  
  coefs = double(kk)

  for (i in seq_along(coefs)) {
    coefs[i] = sum(
      bank[i,] * y
    )
  }
  
  normer = ifelse(forward, 1/N, 2)
  coefs = coefs * normer
  coefs[1] = coefs[1] / sqrt(2)
  
  coefs
  
}
```

```{r}
quick(dct_base)(y, kk=5L)
```

```{r}
coefs <- dct(y, norm_forward = T)

cbind(
  t((y %*% cos_bank(9))/10),
  coefs
)
```

```{r}
plot(idct(coefs))
```

```{r}
slow_roll_mean <- function(x, weights, normalize = TRUE) {
  declare(
    type(x = double(NA)),
    type(weights = double(NA)),
    type(normalize = logical(1))
  )
  out <- double(length(x) - length(weights) + 1)
  n <- length(weights)
  if (normalize)
    weights <- weights/sum(weights)*length(weights)

  for(i in seq_along(out)) {
    out[i] <- sum(x[i:(i+n-1)] * weights) / length(weights)
  }
  out
}

quick_roll_mean <- quick(slow_roll_mean)

```

```{r}
speaker_tracks |> 
  norm_track_nearey(
    F1:F3,
    .by = speaker,
    .token_id_col = id,
    .time_col = t
  ) |> 
  filter(
    plt_vclass == "ay0"
  )
```
